堆是一种用数组模拟二叉树的数据结构，可以被看成广度优先遍历后得到的数组。
堆排序是利用堆这种数据结构来进行信息管理的排序方式，好处是只用到额外的常数个存储空间，也就是空间原址性。
利用数组的下标可以找到一个元素的子节点，若有数组A[0..length-1]，某一元素A[i]
<code>
    left = 2*i+1
    right = 2*i+2
</code>
堆排序的第一步是建堆，堆有两种，最大堆和最小堆。
最大堆的性质是：一个父节点要比子节点的值大，例如[8, 7, 5, 3, 4, 2, 1],反例[7, 8, 5, 3, 4, 2, 1](可以看到7小于8， 所以违反来了性质)。
最小堆的性质是：一个父节点要比子节点的值笑，例如[3, 4, 5, 7, 8, 9, 10]
堆排序的第一步是要建堆，首先要有个函数来维护堆的性质。以最大堆为例
<code>
function max_heap(A, i) {
    left = getLeft(A, i)
    right = getRight(A, i)
    largest = i
    if (A[left] > A[largest]) {
        largest = left
    }
    if (A[right] > A[largest]) {
        largest = right
    }
    A[largest], A[i] = A[i], A[largest]
    if (largest != i) {
        max_heap(A, largest)
    }
}
</code>
这个函数是从上向下来维护这个堆的，那么我们要保证从下向上所有节点都满足最大堆的性质，我们调用这个函数可以从下向上建堆。
<code>
function build_heap(A) {
    leaf = A.length//2
    for(i in leaf..0) {
        max_heap(A, i)
    }
}
</code>
建堆以后，利用最大堆的性质排序，因为最大的数一定是在第一个元素，那么就把A[0]同A[A.length-1]换一下位置，
然后缩小堆堆范围(size-1)，这时，堆的第一个元素违反的堆的性质，接下来就利用max_heap函数维护堆的性质，故技重施。
<code> 
function heapsort(A) {
    build_heap(A)
    for(i in size-1..1) {
        exchange(A[i], A[0])
        max_heap(A, i)
    }
}
</code>